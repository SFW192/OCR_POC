# streamlit_app.py
"""
Universal Financial Document OCR using Google Cloud Vision API + Groq AI
Handles: Invoices, P&L Statements, Receipts, Balance Sheets, Financial Reports
"""

import streamlit as st
from PIL import Image
import io
import os
import json
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from pdf2image import convert_from_bytes
from typing import Dict, List, Tuple
from google.cloud import vision
from google.oauth2 import service_account
from groq import Groq
from dotenv import load_dotenv

load_dotenv()

# Configuration
MAX_FILE_SIZE_MB = 10

# -------------------------
# Google Vision API
# -------------------------
@st.cache_resource
def get_vision_client():
    """Initialize Google Vision API client"""
    try:
        json_path = "august-terminus-462709-i3-e55bfc5c1c0f.json"
        if os.path.exists(json_path):
            credentials = service_account.Credentials.from_service_account_file(json_path)
            return vision.ImageAnnotatorClient(credentials=credentials)
        
        if 'gcp_service_account' in st.secrets:
            credentials = service_account.Credentials.from_service_account_info(
                st.secrets["gcp_service_account"]
            )
            return vision.ImageAnnotatorClient(credentials=credentials)
        
        return vision.ImageAnnotatorClient()
    except Exception as e:
        st.error(f"Vision API initialization failed: {e}")
        return None

# -------------------------
# Image Processing
# -------------------------
def prepare_image_for_vision(image: Image.Image, max_size: int = 4000) -> bytes:
    """Convert PIL Image to bytes for Vision API"""
    if max(image.size) > max_size:
        ratio = max_size / max(image.size)
        new_size = tuple(int(dim * ratio) for dim in image.size)
        image = image.resize(new_size, Image.LANCZOS)
    
    if image.mode not in ('RGB', 'L'):
        image = image.convert('RGB')
    
    buf = io.BytesIO()
    image.save(buf, format='PNG')
    return buf.getvalue()

def pdf_to_images(pdf_bytes: bytes, max_pages: int = 10) -> List[Image.Image]:
    """Convert PDF to images"""
    try:
        images = convert_from_bytes(pdf_bytes, dpi=300, first_page=1, last_page=max_pages, fmt='png')
        return images
    except Exception as e:
        st.error(f"PDF conversion failed: {e}")
        return []

# -------------------------
# OCR
# -------------------------
def extract_text_vision_api(image_bytes: bytes, client) -> Dict:
    """Extract text using Google Vision API"""
    if not client:
        return {"error": "Vision API client not initialized"}
    
    try:
        image = vision.Image(content=image_bytes)
        response = client.document_text_detection(image=image)
        
        if response.error.message:
            return {"error": response.error.message}
        
        full_text = response.full_text_annotation.text if response.full_text_annotation else ""
        
        words = []
        for page in response.full_text_annotation.pages:
            for block in page.blocks:
                for paragraph in block.paragraphs:
                    for word in paragraph.words:
                        word_text = "".join([symbol.text for symbol in word.symbols])
                        words.append({"text": word_text, "confidence": word.confidence})
        
        return {
            "full_text": full_text,
            "words": words,
            "avg_confidence": np.mean([w["confidence"] for w in words]) if words else 0
        }
    except Exception as e:
        return {"error": str(e)}

# -------------------------
# Groq AI Extraction
# -------------------------
def extract_financial_data_with_groq(text: str) -> Dict:
    """Extract structured data using Groq AI"""
    try:
        groq_api_key = os.getenv("GROQ_API_KEY")
        if not groq_api_key:
            try:
                groq_api_key = st.secrets.get("GROQ_API_KEY")
            except:
                pass
        
        if not groq_api_key:
            st.error("‚ö†Ô∏è GROQ_API_KEY not found in .env file or secrets")
            st.info("üí° Add GROQ_API_KEY=your_key to your .env file")
            return None
        
        client = Groq(api_key=groq_api_key)
        
        prompt = f"""Analyze this financial document and extract structured data in JSON format.

Document Text:
{text[:8000]}

For Balance Sheet or Financial Statement documents, extract ALL major categories with their values.
For P&L Statements, extract all revenue and expense line items.
For Invoices/Receipts, extract line items with roles/categories and ALL tax components.

Return JSON with this structure (use null for missing data):
{{
    "document_type": "invoice|receipt|p&l_statement|balance_sheet|financial_statement|other",
    "vendor_name": "company name",
    "customer_name": "customer name if available",
    "document_number": "invoice/document number",
    "document_date": "YYYY-MM-DD",
    "due_date": "YYYY-MM-DD if available",
    "tax_id": "GST/tax ID",
    "currency": "INR|USD|EUR|GBP",
    "amounts": {{
        "subtotal": number_or_null,
        "taxable_value": number_or_null,
        "cgst": number_or_null,
        "sgst": number_or_null,
        "igst": number_or_null,
        "tax": number_or_null,
        "total_tax": number_or_null,
        "discount": number_or_null,
        "total": number_or_null,
        "paid": number_or_null,
        "balance": number_or_null
    }},
    "line_items": [
        {{
            "description": "item description",
            "role": "Java|Flutter|Python|DevOps|QA|Design|Angular|Other or null",
            "quantity": number_or_null,
            "unit_price": number_or_null,
            "amount": number,
            "tax_amount": number_or_null,
            "untaxed_amount": number_or_null
        }}
    ],
    "balance_sheet_items": [
        {{
            "category": "Assets|Liabilities|Equity",
            "subcategory": "Current Assets|Non-Current Assets|etc",
            "line_item": "specific item name",
            "current_year": number,
            "previous_year": number_or_null
        }}
    ],
    "pl_statement_items": [
        {{
            "category": "Revenue|Expenses",
            "line_item": "specific item name",
            "current_year": number,
            "previous_year": number_or_null
        }}
    ],
    "financial_metrics": {{
        "revenue": number_or_null,
        "total_income": number_or_null,
        "total_expenses": number_or_null,
        "net_income": number_or_null,
        "profit_margin": number_or_null,
        "total_assets": number_or_null,
        "total_liabilities": number_or_null,
        "total_equity": number_or_null
    }},
    "payment_info": {{
        "payment_method": "string or null",
        "payment_terms": "string or null",
        "bank_details": "string or null"
    }},
    "notes": "additional info"
}}

CRITICAL INSTRUCTIONS:
- Extract EXACT numbers from the document - DO NOT calculate or derive values
- For invoices: Extract taxable_value, CGST, SGST, IGST, and total_tax separately
- For line items: Identify specific roles (Java, Flutter, Angular, Python, DevOps, QA, Design) from descriptions
- For balance sheets: Extract ALL line items with exact values for both years
- For financial statements: Extract total_assets, total_liabilities for BOTH current and previous year
- Use null only when data is truly missing from the document
- Preserve all numerical precision from the source document

Return ONLY valid JSON, no explanations."""

        response = client.chat.completions.create(
            model="llama-3.3-70b-versatile",
            messages=[
                {"role": "system", "content": "Extract structured financial data with exact precision. Return valid JSON only."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.1,
            max_tokens=4000
        )
        
        result = response.choices[0].message.content
        
        if '```json' in result:
            result = result.split('```json')[1].split('```')[0].strip()
        elif '```' in result:
            result = result.split('```')[1].split('```')[0].strip()
        
        return json.loads(result)
        
    except Exception as e:
        st.error(f"Groq extraction error: {str(e)}")
        return None

# -------------------------
# Utility Functions
# -------------------------
def safe_format_amount(value, currency_symbol='‚Çπ'):
    """Safely format amounts"""
    if value is None or (isinstance(value, float) and np.isnan(value)):
        return None
    try:
        return f"{currency_symbol}{float(value):,.2f}"
    except:
        return None

def safe_get(data, key, default=None):
    """Safely get dictionary value"""
    value = data.get(key)
    if value in (None, '', 'null'):
        return default
    return value

# -------------------------
# DataFrame Creation
# -------------------------
def create_dataframes(groq_data: Dict) -> Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]:
    """Create DataFrames from extracted data"""
    
    # Line items DataFrame (for invoices/receipts)
    line_items = groq_data.get('line_items', [])
    if line_items:
        df_items = pd.DataFrame(line_items)
        df_items['document_type'] = groq_data.get('document_type')
        df_items['vendor_name'] = groq_data.get('vendor_name')
        df_items['document_date'] = groq_data.get('document_date')
        df_items['currency'] = groq_data.get('currency', 'INR')
        
        for col in ['quantity', 'unit_price', 'amount', 'tax_amount', 'untaxed_amount']:
            if col in df_items.columns:
                df_items[col] = pd.to_numeric(df_items[col], errors='coerce').fillna(0)
        
        # Calculate untaxed and tax if not present but amount exists
        if 'amount' in df_items.columns and df_items['amount'].sum() > 0:
            if 'untaxed_amount' not in df_items.columns or df_items['untaxed_amount'].sum() == 0:
                if 'tax_amount' in df_items.columns and df_items['tax_amount'].sum() > 0:
                    df_items['untaxed_amount'] = df_items['amount'] - df_items['tax_amount']
            if 'tax_amount' not in df_items.columns or df_items['tax_amount'].sum() == 0:
                if 'untaxed_amount' in df_items.columns and df_items['untaxed_amount'].sum() > 0:
                    df_items['tax_amount'] = df_items['amount'] - df_items['untaxed_amount']
    else:
        df_items = pd.DataFrame()
    
    # Balance sheet DataFrame
    balance_sheet_items = groq_data.get('balance_sheet_items', [])
    if balance_sheet_items:
        df_balance = pd.DataFrame(balance_sheet_items)
        for col in ['current_year', 'previous_year']:
            if col in df_balance.columns:
                df_balance[col] = pd.to_numeric(df_balance[col], errors='coerce').fillna(0)
    else:
        df_balance = pd.DataFrame()
    
    # P&L statement DataFrame
    pl_items = groq_data.get('pl_statement_items', [])
    if pl_items:
        df_pl = pd.DataFrame(pl_items)
        for col in ['current_year', 'previous_year']:
            if col in df_pl.columns:
                df_pl[col] = pd.to_numeric(df_pl[col], errors='coerce').fillna(0)
    else:
        df_pl = pd.DataFrame()
    
    # Summary DataFrame
    amounts = groq_data.get('amounts', {})
    metrics = groq_data.get('financial_metrics', {})
    
    summary_data = {
        'document_type': groq_data.get('document_type'),
        'vendor_name': groq_data.get('vendor_name'),
        'document_number': groq_data.get('document_number'),
        'document_date': groq_data.get('document_date'),
        'currency': groq_data.get('currency', 'INR'),
        'subtotal': amounts.get('subtotal'),
        'taxable_value': amounts.get('taxable_value'),
        'cgst': amounts.get('cgst'),
        'sgst': amounts.get('sgst'),
        'igst': amounts.get('igst'),
        'tax': amounts.get('tax'),
        'total_tax': amounts.get('total_tax'),
        'discount': amounts.get('discount'),
        'total': amounts.get('total'),
        'paid': amounts.get('paid'),
        'balance': amounts.get('balance'),
        'revenue': metrics.get('revenue'),
        'total_income': metrics.get('total_income'),
        'total_expenses': metrics.get('total_expenses'),
        'net_income': metrics.get('net_income'),
        'total_assets': metrics.get('total_assets'),
        'total_liabilities': metrics.get('total_liabilities'),
        'total_equity': metrics.get('total_equity')
    }
    
    df_summary = pd.DataFrame([summary_data])
    
    for col in df_summary.columns:
        if col not in ['document_type', 'vendor_name', 'document_number', 'document_date', 'currency']:
            df_summary[col] = pd.to_numeric(df_summary[col], errors='coerce')
    
    # Combine balance sheet and P&L into a unified financial statement dataframe
    df_financial = pd.DataFrame()
    if not df_balance.empty:
        df_financial = df_balance.copy()
        df_financial['statement_type'] = 'balance_sheet'
    if not df_pl.empty:
        df_pl_copy = df_pl.copy()
        df_pl_copy['statement_type'] = 'pl_statement'
        if 'subcategory' not in df_pl_copy.columns:
            df_pl_copy['subcategory'] = None
        df_financial = pd.concat([df_financial, df_pl_copy], ignore_index=True)
    
    return df_items, df_financial, df_summary

# -------------------------
# Dashboard
# -------------------------
def show_dashboard(groq_data: Dict, df_items: pd.DataFrame, df_financial: pd.DataFrame, df_summary: pd.DataFrame):
    """Display financial dashboard"""
    
    st.markdown("---")
    st.markdown("## üìä Financial Analytics Dashboard")
    
    currency = groq_data.get('currency', 'INR')
    currency_symbol = '‚Çπ' if currency == 'INR' else ('$' if currency == 'USD' else '‚Ç¨' if currency == 'EUR' else '¬£' if currency == 'GBP' else currency)
    
    doc_type = groq_data.get('document_type', '').lower()
    
    # Summary Metrics based on document type
    st.markdown("### üí∞ Financial Summary")
    
    if doc_type in ['balance_sheet', 'financial_statement']:
        # Extract totals from balance sheet items
        df_bs = df_financial[df_financial['statement_type'] == 'balance_sheet'].copy() if 'statement_type' in df_financial.columns else df_financial.copy()
        
        if not df_bs.empty:
            # Calculate totals from balance sheet items
            if 'category' in df_bs.columns:
                assets_current = df_bs[df_bs['category'] == 'Assets']['current_year'].sum()
                assets_previous = df_bs[df_bs['category'] == 'Assets']['previous_year'].sum() if 'previous_year' in df_bs.columns else 0
                
                liabilities_current = df_bs[df_bs['category'] == 'Liabilities']['current_year'].sum()
                liabilities_previous = df_bs[df_bs['category'] == 'Liabilities']['previous_year'].sum() if 'previous_year' in df_bs.columns else 0
                
                equity_current = df_bs[df_bs['category'] == 'Equity']['current_year'].sum()
                equity_previous = df_bs[df_bs['category'] == 'Equity']['previous_year'].sum() if 'previous_year' in df_bs.columns else 0
            else:
                assets_current = df_bs['current_year'].sum()
                assets_previous = df_bs['previous_year'].sum() if 'previous_year' in df_bs.columns else 0
                liabilities_current = 0
                liabilities_previous = 0
                equity_current = 0
                equity_previous = 0
            
            # Display metrics with year-over-year comparison
            st.markdown("#### Key Financial Metrics Comparison")
            
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                if assets_current > 0:
                    delta = assets_current - assets_previous if assets_previous > 0 else None
                    delta_pct = f"{((assets_current - assets_previous) / assets_previous * 100):+.1f}%" if assets_previous > 0 else None
                    st.metric("Total Assets (Current)", f"{currency_symbol}{assets_current:,.2f}", 
                             delta=f"{currency_symbol}{delta:,.2f} ({delta_pct})" if delta is not None else None)
                    if assets_previous > 0:
                        st.caption(f"Previous: {currency_symbol}{assets_previous:,.2f}")
            
            with col2:
                if liabilities_current > 0:
                    delta = liabilities_current - liabilities_previous if liabilities_previous > 0 else None
                    delta_pct = f"{((liabilities_current - liabilities_previous) / liabilities_previous * 100):+.1f}%" if liabilities_previous > 0 else None
                    st.metric("Total Liabilities (Current)", f"{currency_symbol}{liabilities_current:,.2f}",
                             delta=f"{currency_symbol}{delta:,.2f} ({delta_pct})" if delta is not None else None)
                    if liabilities_previous > 0:
                        st.caption(f"Previous: {currency_symbol}{liabilities_previous:,.2f}")
            
            with col3:
                if equity_current > 0:
                    delta = equity_current - equity_previous if equity_previous > 0 else None
                    delta_pct = f"{((equity_current - equity_previous) / equity_previous * 100):+.1f}%" if equity_previous > 0 else None
                    st.metric("Total Equity (Current)", f"{currency_symbol}{equity_current:,.2f}",
                             delta=f"{currency_symbol}{delta:,.2f} ({delta_pct})" if delta is not None else None)
                    if equity_previous > 0:
                        st.caption(f"Previous: {currency_symbol}{equity_previous:,.2f}")
            
            with col4:
                metrics = groq_data.get('financial_metrics', {})
                net_income = metrics.get('net_income')
                if net_income:
                    st.metric("Net Income", f"{currency_symbol}{net_income:,.2f}")
        
        # Balance Sheet Visualization
        if not df_bs.empty and 'current_year' in df_bs.columns:
            st.markdown("---")
            st.markdown("### üìà Balance Sheet Analysis")
            
            if len(df_bs) > 0:
                col1, col2 = st.columns(2)
                
                with col1:
                    st.markdown("#### Top Items by Value (Current Year)")
                    top_items = df_bs.nlargest(10, 'current_year')
                    
                    fig1 = px.bar(
                        top_items,
                        x='current_year',
                        y='line_item',
                        orientation='h',
                        labels={'current_year': f'Amount ({currency_symbol})', 'line_item': 'Item'},
                        color='category' if 'category' in top_items.columns else None
                    )
                    fig1.update_traces(
                        texttemplate=f'{currency_symbol}%{{x:,.0f}}',
                        textposition='outside',
                        hovertemplate=f'<b>%{{y}}</b><br>Amount: {currency_symbol}%{{x:,.2f}}<extra></extra>'
                    )
                    fig1.update_layout(
                        yaxis={'categoryorder': 'total ascending'},
                        xaxis=dict(tickformat=',.0f'),
                        height=500,
                        showlegend=True if 'category' in top_items.columns else False
                    )
                    st.plotly_chart(fig1, use_container_width=True)
                
                with col2:
                    st.markdown("#### Category Distribution")
                    
                    if 'category' in df_bs.columns:
                        category_totals = df_bs.groupby('category')['current_year'].sum().reset_index()
                        category_totals = category_totals[category_totals['current_year'] > 0]
                        
                        if not category_totals.empty:
                            fig2 = px.pie(
                                category_totals,
                                values='current_year',
                                names='category',
                                hole=0.4
                            )
                            fig2.update_traces(
                                texttemplate='%{label}<br>' + f'{currency_symbol}%{{value:,.0f}}',
                                textposition='inside',
                                hovertemplate=f'<b>%{{label}}</b><br>Amount: {currency_symbol}%{{value:,.2f}}<br>Percentage: %{{percent}}<extra></extra>'
                            )
                            fig2.update_layout(height=500, showlegend=True)
                            st.plotly_chart(fig2, use_container_width=True)
    
    elif doc_type in ['p&l_statement', 'pl_statement']:
        # Extract totals from P&L items
        df_pl = df_financial[df_financial['statement_type'] == 'pl_statement'].copy() if 'statement_type' in df_financial.columns else df_financial.copy()
        
        if not df_pl.empty and 'category' in df_pl.columns:
            income_current = df_pl[df_pl['category'] == 'Revenue']['current_year'].sum()
            income_previous = df_pl[df_pl['category'] == 'Revenue']['previous_year'].sum() if 'previous_year' in df_pl.columns else 0
            
            expenses_current = df_pl[df_pl['category'] == 'Expenses']['current_year'].sum()
            expenses_previous = df_pl[df_pl['category'] == 'Expenses']['previous_year'].sum() if 'previous_year' in df_pl.columns else 0
            
            net_current = income_current - expenses_current
            net_previous = income_previous - expenses_previous
            
            st.markdown("#### Key P&L Metrics Comparison")
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                if income_current > 0:
                    delta = income_current - income_previous if income_previous > 0 else None
                    delta_pct = f"{((income_current - income_previous) / income_previous * 100):+.1f}%" if income_previous > 0 else None
                    st.metric("Total Income (Current)", f"{currency_symbol}{income_current:,.2f}",
                             delta=f"{currency_symbol}{delta:,.2f} ({delta_pct})" if delta is not None else None)
                    if income_previous > 0:
                        st.caption(f"Previous: {currency_symbol}{income_previous:,.2f}")
            
            with col2:
                if expenses_current > 0:
                    delta = expenses_current - expenses_previous if expenses_previous > 0 else None
                    delta_pct = f"{((expenses_current - expenses_previous) / expenses_previous * 100):+.1f}%" if expenses_previous > 0 else None
                    st.metric("Total Expenses (Current)", f"{currency_symbol}{expenses_current:,.2f}",
                             delta=f"{currency_symbol}{delta:,.2f} ({delta_pct})" if delta is not None else None)
                    if expenses_previous > 0:
                        st.caption(f"Previous: {currency_symbol}{expenses_previous:,.2f}")
            
            with col3:
                delta = net_current - net_previous if net_previous != 0 else None
                delta_pct = f"{((net_current - net_previous) / net_previous * 100):+.1f}%" if net_previous != 0 else None
                st.metric("Net Income (Current)", f"{currency_symbol}{net_current:,.2f}",
                         delta=f"{currency_symbol}{delta:,.2f} ({delta_pct})" if delta is not None else None)
                if net_previous != 0:
                    st.caption(f"Previous: {currency_symbol}{net_previous:,.2f}")
    
    else:
        # Invoice/Receipt visualization with ALL tax components
        amounts = groq_data.get('amounts', {})
        col1, col2, col3, col4, col5 = st.columns(5)
        
        # Calculate from line items if amounts not available
        calc_subtotal = 0
        calc_tax = 0
        calc_total = 0
        
        if not df_items.empty:
            if 'untaxed_amount' in df_items.columns:
                calc_subtotal = df_items['untaxed_amount'].sum()
            if 'tax_amount' in df_items.columns:
                calc_tax = df_items['tax_amount'].sum()
            if 'amount' in df_items.columns:
                calc_total = df_items['amount'].sum()
        
        with col1:
            taxable_value = amounts.get('taxable_value') or amounts.get('subtotal') or calc_subtotal
            if taxable_value:
                st.metric("Taxable Value", f"{currency_symbol}{taxable_value:,.2f}")
        
        with col2:
            cgst = amounts.get('cgst')
            if cgst:
                st.metric("CGST", f"{currency_symbol}{cgst:,.2f}")
        
        with col3:
            sgst = amounts.get('sgst')
            if sgst:
                st.metric("SGST", f"{currency_symbol}{sgst:,.2f}")
        
        with col4:
            total_tax = amounts.get('total_tax') or amounts.get('tax') or calc_tax
            if total_tax:
                st.metric("Total Tax", f"{currency_symbol}{total_tax:,.2f}")
        
        with col5:
            total = amounts.get('total') or calc_total
            if total:
                st.metric("Total Amount", f"{currency_symbol}{total:,.2f}")
        
        # Display tax breakdown table
        if cgst or sgst or amounts.get('igst'):
            st.markdown("---")
            st.markdown("### üìã Tax Breakdown")
            
            tax_data = []
            if cgst:
                tax_data.append({"Tax Component": "CGST", "Amount": f"{currency_symbol}{cgst:,.2f}"})
            if sgst:
                tax_data.append({"Tax Component": "SGST", "Amount": f"{currency_symbol}{sgst:,.2f}"})
            if amounts.get('igst'):
                tax_data.append({"Tax Component": "IGST", "Amount": f"{currency_symbol}{amounts.get('igst'):,.2f}"})
            if total_tax:
                tax_data.append({"Tax Component": "Total Tax", "Amount": f"{currency_symbol}{total_tax:,.2f}"})
            
            if tax_data:
                st.dataframe(pd.DataFrame(tax_data), use_container_width=True, hide_index=True)
        
        # Role-based grouping for invoices
        if not df_items.empty and 'role' in df_items.columns and df_items['role'].notna().any():
            st.markdown("---")
            st.markdown("### üë• Analysis by Role/Category")
            
            # Filter out null/None roles and group
            df_items_with_role = df_items[df_items['role'].notna() & (df_items['role'] != 'Other') & (df_items['role'] != '')].copy()
            
            if not df_items_with_role.empty:
                role_summary = df_items_with_role.groupby('role').agg({
                    'amount': 'sum',
                    'untaxed_amount': 'sum',
                    'tax_amount': 'sum',
                    'quantity': 'sum'
                }).reset_index()
                
                role_summary = role_summary[role_summary['amount'] > 0].sort_values('amount', ascending=False)
                
                col1, col2 = st.columns(2)
                
                with col1:
                    st.markdown("#### Amount by Role")
                    fig1 = px.bar(
                        role_summary,
                        x='role',
                        y='amount',
                        text='amount',
                        labels={'amount': f'Total Amount ({currency_symbol})', 'role': 'Role'},
                        color='role',
                        color_discrete_sequence=px.colors.qualitative.Set3
                    )
                    fig1.update_traces(
                        texttemplate=f'{currency_symbol}%{{y:,.2f}}',
                        textposition='outside',
                        hovertemplate='<b>%{x}</b><br>Total: ' + f'{currency_symbol}%{{y:,.2f}}<extra></extra>'
                    )
                    fig1.update_layout(
                        height=400,
                        showlegend=False,
                        xaxis_title='Role',
                        yaxis_title=f'Amount ({currency_symbol})',
                        xaxis={'tickangle': -45}
                    )
                    st.plotly_chart(fig1, use_container_width=True)
                
                with col2:
                    st.markdown("#### Role Distribution")
                    fig2 = px.pie(
                        role_summary,
                        values='amount',
                        names='role',
                        hole=0.4,
                        color_discrete_sequence=px.colors.qualitative.Set3
                    )
                    fig2.update_traces(
                        texttemplate='%{label}<br>' + f'{currency_symbol}%{{value:,.0f}}<br>%{{percent}}',
                        textposition='inside',
                        hovertemplate='<b>%{label}</b><br>Amount: ' + f'{currency_symbol}%{{value:,.2f}}<br>Percentage: %{{percent}}<extra></extra>'
                    )
                    fig2.update_layout(height=400)
                    st.plotly_chart(fig2, use_container_width=True)

# -------------------------
# Login Page
# -------------------------
def show_login_page():
    """Display login page with SFW Technologies branding"""
    
    col1, col2, col3 = st.columns([1, 2, 1])
    
    with col2:
        try:
            col_logo1, col_logo2, col_logo3 = st.columns([1, 2, 1])
            with col_logo2:
                st.image(
                    "https://softworkstech.com/wp-content/uploads/2022/09/softworklogo.svg",
                    use_container_width=True
                )
        except:
            st.markdown("<h3 style='text-align: center;'>üè¢ SFW Technologies</h3>", unsafe_allow_html=True)
        
        st.markdown("<br>", unsafe_allow_html=True)
        
        st.markdown("<h3 style='text-align: center;'>üîê Login to Financial Document OCR</h3>", unsafe_allow_html=True)
        st.markdown("---")
        
        with st.form("login_form"):
            username = st.text_input("Username", placeholder="Enter username")
            password = st.text_input("Password", type="password", placeholder="Enter password")
            submit = st.form_submit_button("Login", use_container_width=True, type="primary")
            
            if submit:
                if username == "sfw" and password == "admin":
                    st.session_state.logged_in = True
                    st.session_state.username = username
                    st.success("‚úÖ Login successful!")
                    st.rerun()
                else:
                    st.error("‚ùå Invalid username or password")
                    st.info("üí° Default credentials:\n- Username: **sfw**\n- Password: **admin**")
        
    st.markdown("---")
    st.markdown("""
    <div style='text-align: center; color: #666;'>
        <small>¬© 2025 SFW Technologies. All rights reserved.</small>
    </div>
    """, unsafe_allow_html=True)


def main():
    """Main entrypoint for the Streamlit app"""
    st.set_page_config(page_title="Universal Financial Document OCR", layout="wide")
    
    # Initialize session state
    if "logged_in" not in st.session_state:
        st.session_state.logged_in = False
    if "username" not in st.session_state:
        st.session_state.username = None
    if "ocr_text" not in st.session_state:
        st.session_state.ocr_text = None
    if "ocr_confidence" not in st.session_state:
        st.session_state.ocr_confidence = None
    if "groq_data" not in st.session_state:
        st.session_state.groq_data = None
    
    # Simple nav: login vs app
    if not st.session_state.logged_in:
        show_login_page()
        return
    
    # Logged-in app UI
    st.sidebar.header(f"Welcome, {st.session_state.username}")
    if st.sidebar.button("Logout"):
        st.session_state.logged_in = False
        st.session_state.username = None
        st.session_state.ocr_text = None
        st.session_state.ocr_confidence = None
        st.session_state.groq_data = None
        st.rerun()
    
    st.title("üìÑ Upload Financial Document (Invoice / P&L / Balance Sheet)")
    uploaded = st.file_uploader("Upload PDF / PNG / JPG (max 10MB)", type=['pdf', 'png', 'jpg', 'jpeg'], accept_multiple_files=False)
    
    if uploaded is None:
        st.info("Upload a document to begin OCR ‚Üí Structured extraction ‚Üí Dashboard")
        # Reset session state when file is removed
        st.session_state.ocr_text = None
        st.session_state.ocr_confidence = None
        st.session_state.groq_data = None
        return
    
    # Size guard
    uploaded.seek(0, os.SEEK_END)
    size_mb = uploaded.tell() / (1024 * 1024)
    uploaded.seek(0)
    if size_mb > MAX_FILE_SIZE_MB:
        st.error(f"File too large ({size_mb:.1f} MB). Max allowed: {MAX_FILE_SIZE_MB} MB.")
        return
    
    # Check if this is a new file upload
    file_key = f"{uploaded.name}_{size_mb}"
    if "last_file_key" not in st.session_state or st.session_state.last_file_key != file_key:
        # New file uploaded, reset everything
        st.session_state.ocr_text = None
        st.session_state.ocr_confidence = None
        st.session_state.groq_data = None
        st.session_state.last_file_key = file_key
    
    # Run OCR only if not already done
    if st.session_state.ocr_text is None:
        # Convert to images (if pdf) or load image
        file_bytes = uploaded.read()
        
        images = []
        if uploaded.name.lower().endswith('.pdf'):
            images = pdf_to_images(file_bytes, max_pages=10)
            if not images:
                st.error("Failed to convert PDF pages to images.")
                return
        else:
            try:
                pil_img = Image.open(io.BytesIO(file_bytes))
                images = [pil_img.convert('RGB')]
            except Exception as e:
                st.error(f"Failed to read image file: {e}")
                return
        
        # Initialize Vision client
        vision_client = get_vision_client()
        if vision_client is None:
            st.error("Vision API client could not be initialized. Check credentials.")
            return
        
        # OCR each page and concatenate text
        full_texts = []
        confidences = []
        with st.spinner("Running OCR..."):
            for i, img in enumerate(images):
                try:
                    img_bytes = prepare_image_for_vision(img)
                    ocr_result = extract_text_vision_api(img_bytes, vision_client)
                    if 'error' in ocr_result:
                        st.error(f"OCR error on page {i+1}: {ocr_result['error']}")
                    else:
                        full_texts.append(ocr_result.get('full_text', ''))
                        confidences.append(ocr_result.get('avg_confidence', 0))
                except Exception as e:
                    st.error(f"Unexpected OCR failure on page {i+1}: {e}")
        
        combined_text = "\n\n".join([t for t in full_texts if t])
        avg_conf = float(np.mean(confidences)) if confidences else 0.0
        
        # Store in session state
        st.session_state.ocr_text = combined_text
        st.session_state.ocr_confidence = avg_conf
    
    # Display OCR results
    st.markdown(f"**OCR Average Confidence:** {st.session_state.ocr_confidence:.2f}")
    st.expander("üìÑ Show OCR text", expanded=False).text(st.session_state.ocr_text[:20000] or "No text recognized")
    
    # Extract structured data button
    if st.button("Extract Structured Financial Data", type="primary"):
        with st.spinner("Extracting structured data AI..."):
            groq_data = extract_financial_data_with_groq(st.session_state.ocr_text)
        
        if groq_data is None:
            st.error("Extraction failed or returned no data.")
            return
        
        # Store in session state
        st.session_state.groq_data = groq_data
    
    # Display results if available
    if st.session_state.groq_data:
        groq_data = st.session_state.groq_data
        
        # Show raw JSON
        st.subheader("Extracted JSON")
        st.json(groq_data)
        
        df_items, df_financial, df_summary = create_dataframes(groq_data)
        
        # Show dashboard
        show_dashboard(groq_data, df_items, df_financial, df_summary)
        
        # Data exports
        with st.expander("üì• Download Extracted Tables"):
            if not df_items.empty:
                csv_items = df_items.to_csv(index=False).encode('utf-8')
                st.download_button("Download Line Items CSV", data=csv_items, file_name="line_items.csv", mime="text/csv")
            if not df_financial.empty:
                csv_fin = df_financial.to_csv(index=False).encode('utf-8')
                st.download_button("Download Financials CSV", data=csv_fin, file_name="financials.csv", mime="text/csv")
            csv_summary = df_summary.to_csv(index=False).encode('utf-8')
            st.download_button("Download Summary CSV", data=csv_summary, file_name="summary.csv", mime="text/csv")


if __name__ == "__main__":
    main()
